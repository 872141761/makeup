# 命名规范

命名规范对于 Go 和其他编程语言一样，都是非常重要的。Go 语言中的命名甚至有语义上的作用：命名在包外的可见性取决于它的首字母是否大写。所以花一点时间解释一下 Go 语言的命名规范还是有必要的。

## 包的命名

当一个包被 import 后，包的名字就会变成包内容的 accessor。在`import "bytes"`后，你可以这样访问它的内容：`bytes.Buffer`。包的使用者都使用同样的名字来访问包的内容，这就要求包的命名要优雅：短小、简洁、容易记忆。按照惯例，包的命名是全小写的单个单词；不能用下划线或者驼峰。注意让包名简短，因为每个使用者都要去敲这个名字。不要担心名字冲突。包名只是 import 使用的默认名称；它不需要在整个源代码中全局唯一，在极少的命名冲突的情况下，import 的包可以用其他名字。发生命名冲突的情况是罕见的，因为在 import 中的文件名会决定到底哪个包被导入了。

另一个惯例是，包的名字是它所在文件路径的 base name。例如在`/src/encoding/base64`中的包，导入时这么写：`encoding/base64`，包的名字却是 base64，不是 encoding_base64 也不是 encodingBase64.

包的导入方使用包名来引用包的内容，所以，在导出包中的变量时可以利用这一点来避免啰嗦（不要使用`import .`表示法，这种表示法可以简化那些只能在包外运行的测试，除此之外都不应使用）。举例来说，在`bufio`中定义的带缓冲的 reader 被命名为`Reader`而不是`BufReader`，因为在使用者看来他是`bufio.Reader`，这已经是很简单明了的名字了。同样的，因为被引入的内容永远要用他们的包名来引用，`bufio.Reader`就不会和`io.Reader`冲突。类似的，构造`ring.Ring`的函数（构造函数）或许应该命名为`NewRing`，但是因为`Ring`是这个包导出的唯一一个类型，而包的名字又是`ring`，构造函数就可以简单的命名为`New`.在使用者看来，他就是`ring.New`。利用好这种包结构，可以帮你更好的命名。

另一个简短的例子是`once.Do`。`once.Do(setup)`可读性很好，可是如果写成`once.DoOrWaitUntilDone(setup)`并不会更好。更长的名字并不一定会让可读性更好。良好的注释常常比一个冗长的名字更有帮助。

## Getters

Go 不提供对 getter 和 setter 的自动支持。由你来提供 getter 和 setter 方法并没有什么错，而且有时还会更好。但是 getter 方法的开头并没有必要是 Get，这也不符合 Go 语言的惯用法。如果你有一个字段是 owner（小写，私有），那么对应的 getter 方法是 Owner（大写，公有）而不是 GetOwner。大写开头的命名提供了区别于对应字段的钩子。setter 方法就会是 SetOwner。这两个命名可读性都很好。

```golang
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

## 接口命名

按照惯例，单方法接口被命名为方法名加 er 结尾，或者类似的构词法构成一个名词：`Reader, Writer, Formatter, CloseNotifier`等。

在生产实践中，把一类特殊的名字和他们持有的方法名特殊对待是很有必要的。例如`Read，Write，Close，Flush，String`等名字都是有权威性的标识符和含义的。为了避免困惑，不要把你的方法命名成以上这种，除非有同样的标识符和含义。如果自定义类型中要实现一个和“著名”类型中相同的方法，那就可以起成相同的名字；把你的字符串转换函数命名成`String`而不是`ToString`。

## 驼峰风格

在 Go 语言中，使用驼峰和小驼峰来组合多个单词，不使用下划线。